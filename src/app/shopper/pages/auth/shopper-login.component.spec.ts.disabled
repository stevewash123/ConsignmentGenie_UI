import { ComponentFixture, TestBed } from '@angular/core/testing';
import { ReactiveFormsModule } from '@angular/forms';
import { RouterTestingModule } from '@angular/router/testing';
import { ActivatedRoute, Router } from '@angular/router';
import { of, throwError, BehaviorSubject } from 'rxjs';
import { Component } from '@angular/core';

import { ShopperLoginComponent } from './shopper-login.component';
import { ShopperAuthService } from '../../services/shopper-auth.service';
import { ShopperStoreService, StoreInfoDto } from '../../services/shopper-store.service';

// Mock component for navigation testing
@Component({
  template: '<div>Mock Component</div>'
})
class MockComponent { }

describe('ShopperLoginComponent', () => {
  let component: ShopperLoginComponent;
  let fixture: ComponentFixture<ShopperLoginComponent>;
  let mockAuthService: jasmine.SpyObj<ShopperAuthService>;
  let mockStoreService: jasmine.SpyObj<ShopperStoreService>;
  let mockRouter: jasmine.SpyObj<Router>;
  let mockActivatedRoute: any;

  const mockStoreInfo: StoreInfoDto = {
    id: '123e4567-e89b-12d3-a456-426614174000',
    name: 'Test Store',
    slug: 'test-store',
    description: 'A test store',
    isActive: true
  };

  beforeEach(async () => {
    const authServiceSpy = jasmine.createSpyObj('ShopperAuthService', [
      'login',
      'isAuthenticated'
    ]);

    const storeServiceSpy = jasmine.createSpyObj('ShopperStoreService', [], {
      currentStore$: new BehaviorSubject<StoreInfoDto | null>(mockStoreInfo)
    });

    const routerSpy = jasmine.createSpyObj('Router', ['navigateByUrl']);

    mockActivatedRoute = {
      paramMap: new BehaviorSubject(new Map([['storeSlug', 'test-store']])),
      queryParams: new BehaviorSubject({ returnUrl: '/shop/test-store' })
    };

    await TestBed.configureTestingModule({
      imports: [
        ShopperLoginComponent,
        ReactiveFormsModule,
        RouterTestingModule.withRoutes([
          { path: 'mock', component: MockComponent }
        ])
      ],
      providers: [
        { provide: ShopperAuthService, useValue: authServiceSpy },
        { provide: ShopperStoreService, useValue: storeServiceSpy },
        { provide: Router, useValue: routerSpy },
        { provide: ActivatedRoute, useValue: mockActivatedRoute }
      ]
    }).compileComponents();

    mockAuthService = TestBed.inject(ShopperAuthService) as jasmine.SpyObj<ShopperAuthService>;
    mockStoreService = TestBed.inject(ShopperStoreService) as jasmine.SpyObj<ShopperStoreService>;
    mockRouter = TestBed.inject(Router) as jasmine.SpyObj<Router>;
  });

  beforeEach(() => {
    fixture = TestBed.createComponent(ShopperLoginComponent);
    component = fixture.componentInstance;
    mockAuthService.isAuthenticated.and.returnValue(false);
    fixture.detectChanges();
  });

  describe('Component Initialization', () => {
    it('should create', () => {
      expect(component).toBeTruthy();
    });

    it('should initialize form with default values', () => {
      expect(component.loginForm.get('email')?.value).toBe('');
      expect(component.loginForm.get('password')?.value).toBe('');
      expect(component.loginForm.get('rememberMe')?.value).toBe(false);
    });

    it('should set store slug from route parameters', () => {
      expect(component.storeSlug).toBe('test-store');
    });

    it('should set return URL from query parameters', () => {
      expect(component.returnUrl).toBe('/shop/test-store');
    });

    it('should set store info from store service', () => {
      expect(component.storeInfo).toEqual(mockStoreInfo);
    });
  });

  describe('Form Validation', () => {
    it('should require email field', () => {
      const emailControl = component.loginForm.get('email');

      emailControl?.setValue('');
      emailControl?.markAsTouched();

      expect(emailControl?.invalid).toBeTruthy();
      expect(emailControl?.errors?.['required']).toBeTruthy();
    });

    it('should validate email format', () => {
      const emailControl = component.loginForm.get('email');

      emailControl?.setValue('invalid-email');
      emailControl?.markAsTouched();

      expect(emailControl?.invalid).toBeTruthy();
      expect(emailControl?.errors?.['email']).toBeTruthy();
    });

    it('should require password field', () => {
      const passwordControl = component.loginForm.get('password');

      passwordControl?.setValue('');
      passwordControl?.markAsTouched();

      expect(passwordControl?.invalid).toBeTruthy();
      expect(passwordControl?.errors?.['required']).toBeTruthy();
    });

    it('should accept valid email and password', () => {
      component.loginForm.patchValue({
        email: 'test@example.com',
        password: 'password123'
      });

      expect(component.loginForm.valid).toBeTruthy();
    });
  });

  describe('Login Functionality', () => {
    beforeEach(() => {
      component.loginForm.patchValue({
        email: 'test@example.com',
        password: 'password123',
        rememberMe: true
      });
    });

    it('should call auth service on valid form submission', () => {
      const mockResponse = {
        success: true,
        token: 'jwt-token',
        shopper: {
          id: '123',
          fullName: 'John Doe',
          email: 'test@example.com'
        }
      };

      mockAuthService.login.and.returnValue(of(mockResponse));

      component.onSubmit();

      expect(mockAuthService.login).toHaveBeenCalledWith('test-store', {
        email: 'test@example.com',
        password: 'password123',
        rememberMe: true
      });
    });

    it('should navigate to return URL on successful login', () => {
      const mockResponse = {
        success: true,
        token: 'jwt-token',
        shopper: {
          id: '123',
          fullName: 'John Doe',
          email: 'test@example.com'
        }
      };

      mockAuthService.login.and.returnValue(of(mockResponse));

      component.onSubmit();

      expect(mockRouter.navigateByUrl).toHaveBeenCalledWith('/shop/test-store');
    });

    it('should show error message on login failure', () => {
      const mockResponse = {
        success: false,
        errorMessage: 'Invalid credentials'
      };

      mockAuthService.login.and.returnValue(of(mockResponse));

      component.onSubmit();

      expect(component.errorMessage).toBe('Invalid credentials');
    });

    it('should handle HTTP error during login', () => {
      const errorMessage = 'Network error';
      mockAuthService.login.and.returnValue(throwError(() => ({ message: errorMessage })));

      component.onSubmit();

      expect(component.errorMessage).toBe(errorMessage);
    });

    it('should not submit if form is invalid', () => {
      component.loginForm.patchValue({
        email: 'invalid-email',
        password: ''
      });

      component.onSubmit();

      expect(mockAuthService.login).not.toHaveBeenCalled();
    });

    it('should show loading state during login', () => {
      const mockResponse = {
        success: true,
        token: 'jwt-token',
        shopper: { id: '123', fullName: 'John Doe', email: 'test@example.com' }
      };

      mockAuthService.login.and.returnValue(of(mockResponse));

      expect(component.isLoading).toBeFalsy();

      component.onSubmit();

      // Loading state is set to false immediately after observable completes
      expect(component.isLoading).toBeFalsy();
    });
  });

  describe('Password Visibility Toggle', () => {
    it('should toggle password visibility', () => {
      expect(component.showPassword).toBeFalsy();

      component.togglePasswordVisibility();

      expect(component.showPassword).toBeTruthy();

      component.togglePasswordVisibility();

      expect(component.showPassword).toBeFalsy();
    });
  });

  describe('Field Validation Helper', () => {
    it('should return true for invalid touched field', () => {
      const emailControl = component.loginForm.get('email');
      emailControl?.setValue('');
      emailControl?.markAsTouched();

      expect(component.isFieldInvalid('email')).toBeTruthy();
    });

    it('should return false for valid field', () => {
      const emailControl = component.loginForm.get('email');
      emailControl?.setValue('test@example.com');
      emailControl?.markAsTouched();

      expect(component.isFieldInvalid('email')).toBeFalsy();
    });

    it('should return false for invalid untouched field', () => {
      const emailControl = component.loginForm.get('email');
      emailControl?.setValue('');

      expect(component.isFieldInvalid('email')).toBeFalsy();
    });
  });

  describe('Forgot Password', () => {
    it('should show alert for forgot password functionality', () => {
      spyOn(window, 'alert');

      const event = new Event('click');
      component.onForgotPassword(event);

      expect(event.defaultPrevented).toBeTruthy();
      expect(window.alert).toHaveBeenCalledWith(
        'Forgot password functionality will be implemented in a future update.'
      );
    });
  });

  describe('Already Authenticated Users', () => {
    it('should redirect if user is already authenticated', () => {
      mockAuthService.isAuthenticated.and.returnValue(true);

      // Simulate route parameter change
      mockActivatedRoute.paramMap.next(new Map([['storeSlug', 'test-store']]));

      expect(mockRouter.navigateByUrl).toHaveBeenCalledWith('/shop/test-store');
    });
  });

  describe('Template Integration', () => {
    it('should display store name in template', () => {
      fixture.detectChanges();

      const compiled = fixture.nativeElement;
      const storeNameElement = compiled.querySelector('.store-name');

      expect(storeNameElement?.textContent?.trim()).toBe('Test Store');
    });

    it('should show error message when present', () => {
      component.errorMessage = 'Test error message';
      fixture.detectChanges();

      const compiled = fixture.nativeElement;
      const errorElement = compiled.querySelector('.error-message .alert');

      expect(errorElement?.textContent?.trim()).toBe('Test error message');
    });

    it('should disable submit button when loading', () => {
      component.isLoading = true;
      fixture.detectChanges();

      const compiled = fixture.nativeElement;
      const submitButton = compiled.querySelector('button[type="submit"]');

      expect(submitButton?.disabled).toBeTruthy();
    });

    it('should disable submit button when form is invalid', () => {
      component.loginForm.patchValue({
        email: 'invalid-email',
        password: ''
      });
      fixture.detectChanges();

      const compiled = fixture.nativeElement;
      const submitButton = compiled.querySelector('button[type="submit"]');

      expect(submitButton?.disabled).toBeTruthy();
    });
  });

  describe('Component Cleanup', () => {
    it('should call destroy subject on component destroy', () => {
      spyOn(component['destroy$'], 'next');
      spyOn(component['destroy$'], 'complete');

      component.ngOnDestroy();

      expect(component['destroy$'].next).toHaveBeenCalled();
      expect(component['destroy$'].complete).toHaveBeenCalled();
    });
  });
});