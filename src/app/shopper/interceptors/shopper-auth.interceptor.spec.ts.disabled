import { TestBed } from '@angular/core/testing';
import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
import { HTTP_INTERCEPTORS, HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';

import { ShopperAuthInterceptor } from './shopper-auth.interceptor';
import { ShopperAuthService } from '../services/shopper-auth.service';

describe('ShopperAuthInterceptor', () => {
  let httpClient: HttpClient;
  let httpTestingController: HttpTestingController;
  let mockAuthService: jasmine.SpyObj<ShopperAuthService>;
  let mockRouter: jasmine.SpyObj<Router>;

  beforeEach(() => {
    const authServiceSpy = jasmine.createSpyObj('ShopperAuthService', [
      'getToken',
      'logout'
    ]);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);

    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        {
          provide: HTTP_INTERCEPTORS,
          useClass: ShopperAuthInterceptor,
          multi: true
        },
        { provide: ShopperAuthService, useValue: authServiceSpy },
        { provide: Router, useValue: routerSpy }
      ]
    });

    httpClient = TestBed.inject(HttpClient);
    httpTestingController = TestBed.inject(HttpTestingController);
    mockAuthService = TestBed.inject(ShopperAuthService) as jasmine.SpyObj<ShopperAuthService>;
    mockRouter = TestBed.inject(Router) as jasmine.SpyObj<Router>;
  });

  afterEach(() => {
    httpTestingController.verify();
  });

  describe('Token Injection', () => {
    it('should add Authorization header for shopper API requests', () => {
      const testToken = 'test-jwt-token';
      const testUrl = 'http://localhost:5000/api/shop/test-store/auth/login';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(req.request.headers.has('Authorization')).toBeTruthy();
      expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);

      req.flush({});
    });

    it('should extract store slug from URL and get appropriate token', () => {
      const testToken = 'store-specific-token';
      const testUrl = 'http://localhost:5000/api/shop/my-store/profile';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(mockAuthService.getToken).toHaveBeenCalledWith('my-store');
      expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);

      req.flush({});
    });

    it('should not add Authorization header for non-shopper API requests', () => {
      const testUrl = 'http://localhost:5000/api/admin/users';

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(req.request.headers.has('Authorization')).toBeFalsy();
      expect(mockAuthService.getToken).not.toHaveBeenCalled();

      req.flush({});
    });

    it('should not add Authorization header when no token is available', () => {
      const testUrl = 'http://localhost:5000/api/shop/test-store/info';

      mockAuthService.getToken.and.returnValue(null);

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(req.request.headers.has('Authorization')).toBeFalsy();
      expect(mockAuthService.getToken).toHaveBeenCalledWith('test-store');

      req.flush({});
    });

    it('should handle requests to external APIs without modification', () => {
      const testUrl = 'https://external-api.com/data';

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(req.request.headers.has('Authorization')).toBeFalsy();
      expect(mockAuthService.getToken).not.toHaveBeenCalled();

      req.flush({});
    });
  });

  describe('Error Handling', () => {
    it('should handle 401 unauthorized responses by logging out and redirecting', () => {
      const testToken = 'expired-token';
      const testUrl = 'http://localhost:5000/api/shop/test-store/profile';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe({
        next: () => fail('Should have failed with 401'),
        error: (error) => {
          expect(error.status).toBe(401);
        }
      });

      const req = httpTestingController.expectOne(testUrl);
      req.error(new ErrorEvent('Unauthorized'), { status: 401 });

      expect(mockAuthService.logout).toHaveBeenCalledWith('test-store');
      expect(mockRouter.navigate).toHaveBeenCalledWith(
        ['/shop', 'test-store', 'login'],
        { queryParams: { returnUrl: '/shop/test-store/profile' } }
      );
    });

    it('should not handle non-401 errors', () => {
      const testToken = 'valid-token';
      const testUrl = 'http://localhost:5000/api/shop/test-store/profile';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe({
        next: () => fail('Should have failed with 500'),
        error: (error) => {
          expect(error.status).toBe(500);
        }
      });

      const req = httpTestingController.expectOne(testUrl);
      req.error(new ErrorEvent('Server Error'), { status: 500 });

      expect(mockAuthService.logout).not.toHaveBeenCalled();
      expect(mockRouter.navigate).not.toHaveBeenCalled();
    });

    it('should not handle 401 errors for non-shopper API requests', () => {
      const testUrl = 'http://localhost:5000/api/admin/users';

      httpClient.get(testUrl).subscribe({
        next: () => fail('Should have failed with 401'),
        error: (error) => {
          expect(error.status).toBe(401);
        }
      });

      const req = httpTestingController.expectOne(testUrl);
      req.error(new ErrorEvent('Unauthorized'), { status: 401 });

      expect(mockAuthService.logout).not.toHaveBeenCalled();
      expect(mockRouter.navigate).not.toHaveBeenCalled();
    });
  });

  describe('URL Pattern Matching', () => {
    const testCases = [
      {
        url: 'http://localhost:5000/api/shop/my-store/auth/login',
        expectedStoreSlug: 'my-store',
        shouldIntercept: true
      },
      {
        url: 'http://localhost:5000/api/shop/store-123/profile',
        expectedStoreSlug: 'store-123',
        shouldIntercept: true
      },
      {
        url: 'http://localhost:5000/api/shop/awesome-store-name/cart',
        expectedStoreSlug: 'awesome-store-name',
        shouldIntercept: true
      },
      {
        url: 'http://localhost:5000/api/admin/stores',
        expectedStoreSlug: null,
        shouldIntercept: false
      },
      {
        url: 'http://localhost:5000/api/public/health',
        expectedStoreSlug: null,
        shouldIntercept: false
      },
      {
        url: 'https://external-api.com/api/shop/test/data',
        expectedStoreSlug: null,
        shouldIntercept: false
      }
    ];

    testCases.forEach(testCase => {
      it(`should ${testCase.shouldIntercept ? 'intercept' : 'not intercept'} ${testCase.url}`, () => {
        const testToken = 'test-token';

        if (testCase.shouldIntercept) {
          mockAuthService.getToken.and.returnValue(testToken);
        }

        httpClient.get(testCase.url).subscribe();

        const req = httpTestingController.expectOne(testCase.url);

        if (testCase.shouldIntercept) {
          expect(mockAuthService.getToken).toHaveBeenCalledWith(testCase.expectedStoreSlug);

          if (testToken) {
            expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);
          }
        } else {
          expect(mockAuthService.getToken).not.toHaveBeenCalled();
          expect(req.request.headers.has('Authorization')).toBeFalsy();
        }

        req.flush({});
      });
    });
  });

  describe('Store Slug Extraction', () => {
    it('should handle URLs with query parameters', () => {
      const testToken = 'test-token';
      const testUrl = 'http://localhost:5000/api/shop/my-store/orders?page=1&limit=10';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(mockAuthService.getToken).toHaveBeenCalledWith('my-store');
      expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);

      req.flush({});
    });

    it('should handle URLs with fragments', () => {
      const testToken = 'test-token';
      const testUrl = 'http://localhost:5000/api/shop/my-store/profile#personal-info';

      mockAuthService.getToken.and.returnValue(testToken);

      httpClient.get(testUrl).subscribe();

      const req = httpTestingController.expectOne(testUrl);
      expect(mockAuthService.getToken).toHaveBeenCalledWith('my-store');
      expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);

      req.flush({});
    });

    it('should handle complex store slugs', () => {
      const complexSlugs = [
        'store-with-dashes',
        'store123',
        'my_store_with_underscores',
        'StoreWithMixedCase',
        'store.with.dots'
      ];

      complexSlugs.forEach(slug => {
        const testToken = `token-for-${slug}`;
        const testUrl = `http://localhost:5000/api/shop/${slug}/info`;

        mockAuthService.getToken.and.returnValue(testToken);

        httpClient.get(testUrl).subscribe();

        const req = httpTestingController.expectOne(testUrl);
        expect(mockAuthService.getToken).toHaveBeenCalledWith(slug);

        req.flush({});
      });
    });
  });

  describe('Request Methods', () => {
    const httpMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'];

    httpMethods.forEach(method => {
      it(`should intercept ${method} requests to shopper API`, () => {
        const testToken = 'test-token';
        const testUrl = 'http://localhost:5000/api/shop/test-store/profile';

        mockAuthService.getToken.and.returnValue(testToken);

        (httpClient as any)[method.toLowerCase()](testUrl).subscribe();

        const req = httpTestingController.expectOne(testUrl);
        expect(req.request.method).toBe(method);
        expect(req.request.headers.get('Authorization')).toBe(`Bearer ${testToken}`);

        req.flush({});
      });
    });
  });
});